# credit: Dmitrii Koshelev
# https://github.com/dishport/Indifferentiable-hashing-to-ordinary-elliptic-curves-of-j-0-with-the-cost-of-one-exponentiation


# Dmitrii Koshelev (the author of the code) was supported by Web3 Foundation (W3F)
# Throughout the code the notation is consistent with author's article
# [1] "Indifferentiable hashing to ordinary elliptic Fq-curves of j = 0 with the cost of one exponentiation in Fq",
# Designs, Codes and Cryptography, 90:3 (2022), 801-812.

import hashlib
import random
import string

# We assume that the finite field order q != 1 (mod 27) and
# b is a quadratic and cubic residue in Fq. Without loss of generality, we can pick b = 1.
# Also, we need a cubic (resp. quadratic) non-residue (resp. residue) c in Fq.
# Parameters for the BLS12-377 curve E1: y^2 = x^3 + 1:
u = 9586122913090633729
r = u^4 - u^2 + 1
q = ((u - 1)^2 * r) // 3 + u
assert( ceil(log(q,2).n()) == 377 )
assert(q.is_prime())
assert(q % 9 == 7)
m = (q - 7) // 9

Fq = GF(q)
w = Fq(1).nth_root(3)
assert(w != 1)   # w is a primitive 3rd root of unity
w2 = w^2
c = w	# sqrt(c) = w2


##############################################################################


# In [1, Section 2, Appendix] we deal with a Calabi-Yau threefold defined as
# the quotient T := E1 x E1' x E1'' / [w] x [w] x [w],
# where E1', E1'' are the cubic twists of E1
# and [w](x, y) -> (wx, y) is an automorphism of order 3 on E1, E1', and E1''.
# Auxiliary map h': T(Fq) -> E1(Fq):
def hPrime(num0,num1,num2,den, t1,t2):
	v = den^2
	u = num0^2 - v
	v2 = v^2
	v4 = v2^2
	v5 = v*v4
	v8 = v4^2
	th = u*v5*(u*v8)^m   # theta from [1, Section 3]
	print(th)
	print(m)
	print(u)
	print(v5)
	print(v)
	v = th^3*v
	L = [t1, w*t1, w2*t1]
	L.sort()
	n = L.index(t1)

	if v == u:
		X = w^n*th
		Y = num0
	if v == w*u:
		X = th*t1
		Y = num1
	if v == w2*u:
		X = th*t2
		Y = num2
	# elif is not used to respect constant-time execution

	X = X*den
	Z = den
	return X,-Y,Z


# [1, Lemma 1, Appendix] states that T is given in the affine space A^5(y0,y1,y2,t1,t2) by the two equations
# y1^2 - 1 = c*(y0^2 - 1)*t1^3,
# y2^2 - 1 = c^2*(y0^2 - 1)*t2^3,
# where tj := xj/x0.
# The threefold T can be regarded as an elliptic curve in A^3(y0,y1,y2) over the function field F := Fq(s1,s2),
# where sj := tj^3.
# By virtue of [1, Theorem 2] the non-torsion part of the Mordell-Weil group T(F) is generated by phi from [1, Theorem 1].
# Rational map phi: (Fq)^2 -> T(Fq):
def phi(t1,t2):
	s1 = t1^3
	s2 = t2^3
	s1s1 = s1^2
	s2s2 = s2^2
	global s1s2
	s1s2 = s1*s2

	c2 = c^2
	c3 = c*c2
	c4 = c2^2
	a20 = c2*s1s1
	a11 = 2*c3*s1s2
	a10 = 2*c*s1
	a02 = c4*s2s2
	a01 = 2*c2*s2

    # yi = numi/den
	num0 = a20 - a11 + a10 + a02 + a01 - 3
	num1 = -3*a20 + a11 + a10 + a02 - a01 + 1
	num2 = a20 + a11 - a10 - 3*a02 + a01 + 1
	den = a20 - a11 - a10 + a02 - a01 + 1
	return num0,num1,num2,den


# Map h: (Fq)^2 -> E1(Fq)
def h(t1,t2):
	num0,num1,num2,den = phi(t1,t2)
	print("num: ", num0, num1, num2, den, t1, t2)
	X,Y,Z = hPrime(num0,num1,num2,den, t1,t2)
	if s1s2 == 0:
		X = 0; Y = 1; Z = 1
	# Without loss of the admissibility property, h can return any other Fq-point on E1 in the case s1s2 == 0 (see [1, Section 4])
	if den == 0:
		X = 0; Y = 1; Z = 0
	print ("x, y", X/Z, Y/Z)
	return X,Y,Z


# Indifferentiable hash function eta: {0,1}* -> (Fq)^2
def eta(s):
	s = s.encode("utf-8")
	s0 = s + b'0'
	s1 = s + b'1'
	# 512 > 506 = 377 + 128 + 1, hence sha512 provides the 128-bit security level
	# in according to Lemma 14 of the article
	# Brier E., et al.: Efficient indifferentiable hashing into ordinary elliptic curves.
	# In: Rabin T. (ed) Advances in Cryptology - CRYPTO 2010, LNCS, 6223, pp. 237-254. Springer, Berlin (2010).
	hash0 = hashlib.sha512(s0).hexdigest()
	hash0 = int(hash0, base=16)
	hash1 = hashlib.sha512(s1).hexdigest()
	hash1 = int(hash1, base=16)
	return Fq(hash0), Fq(hash1)


# Resulting hash function H: {0,1}* -> E1(Fq)
def H(s):
	t1,t2 = eta(s)
	return h(t1,t2)


##############################################################################


s = "input to the test function"
E1 = EllipticCurve(Fq, [0,1])
X,Y,Z = H(s)
print( f"\nH({s})   =   ({X} : {Y} : {Z})   =   {E1(X,Y,Z)}\n" )
